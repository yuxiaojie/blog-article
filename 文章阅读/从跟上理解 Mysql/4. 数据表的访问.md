## 单表访问方法

下面的一些解释会以 SQL 的形式表现，所以这里会有一个表的定义：

```sql
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```



### 访问方法

MySQL 对 SQL 语法解析完成后，会通过优化器完成优化生成执行计划，这个优化器优化的过程，就是 MySQL 服务在计算如何查询效率更高，因为同时会有多种查询的方式可以完成查询，所以需要尽可能选择一条最优的路径，而这个路径就是 `访问方法`，它表示了 MySQL 该如何去查询数据的方式

> 注意：
>
> 下面的 SQL 说明这样的方式可能会采用对应的访问方法，但是最终还是由优化器根据实际情况考虑采用的



#### const

通过主键或者唯一二级索引进行等值查询的方式，称之为 const，这种方式下，每次查询的都是某一条指定的数据，所以效率非常高。另外如果唯一二级索引是一个联合索引，那么这个联合索引的每一个列都需要做等值比较才行。

```sql
-- const 访问方法
SELECT * FROM single_table WHERE key2 = 3841;

-- NULL 值非常特殊，唯一索引并不限制 NULL 值的数量，查出的数据可能不止一条，所以这不是 const 查询方式
SELECT * FROM single_table WHERE key2 IS NULL;
```



#### ref

例如通过某个普通的二级索引进行等值查询，此时可能会对应多个结果，这时这种查询方式的性能取决于这个值对应的记录的数量，数量越多回表代价越大，数量越少则性能越高，这种方式称为 `ref`

```sql
-- ref 访问方法
SELECT * FROM single_table WHERE key1 = 'abc';

-- 不论唯一二级索引还是普通二级索引，都对 NULL 值数量不做限制，所以 IS NULL 这种方式最多使用 ref 这种方式
SELECT * FROM single_table WHERE key1 IS NULL;

-- 对于联合索引，只要最左边的连续索引列都是等值比较，那么也都可以使用 ref 方式
SELECT * FROM single_table WHERE key_part1 = 'god like';
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary'
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary' AND key_part3 = 'penta kill';

-- 如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为ref了，比如：
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 > 'legendary';
```



#### ref_or_null

在通过二级索引等值查询的基础上，额外再查询 null 值的列，这种方式就是 `ref_or_null`

```sql
-- ref_or_null 访问方式
SELECT * FROM single_table WHERE key1 = 'abc' OR key1 IS NULL;
```



#### range

利用索引进行范围匹配的访问方法称之为 `range`

```sql
-- range 访问方式
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
```



#### index

通过遍历二级索引无需回表的访问方式，称为 `index`

```sql
-- index 访问方式
-- 条件1：搜索条件并不能使用到索引 idx_key_part，因为不是联合索引最左侧开始的
-- 条件2：查询的结果 key_part1, key_part2, key_part3 与 搜索条件 key_part2 在联合索引 idx_key_part 中都有
-- 条件1决定不论如何，这个 SQL 都想需要遍历才行，而条件2决定不论是遍历聚簇索引还是联合索引 idx_key_part 都能通过一次遍历就得到结果，但是通常二级索引的大小会比聚簇索引小很多，意味着相同的数据页会有更多的数据，那么遍历的效率会更高
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
```



#### all

最直接的方式，对于 InnoDB 是可以直接扫描整个聚簇索引的，这种方式就是 `all`



### 注意事项：



#### 二级索引 + 回表

```sql
-- 下面的 SQL 可以使用索引 idx_key1 也可以使用索引 idx_key2
SELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;
```

**一般情况下，一次查询只能使用一个索引**，所以这时如何选择取决于优化器，一般来说，`ref` 类型的结果会比 `range` 类型要少，这个不一定，所以具体选择还是由优化器根据表中数据进行选择

假定优化器选择通过索引 idx_key1 来进行查询，那么

1.  使用二级索引 idx_key1 将 `key1 = 'abc'` 的结果取出
2. 根据上一步的结果的主键值，回表，从聚簇索引中取出所有完整的记录，然后再通过 `key2 > 1000` 条件进行筛选
3. 将筛选后的结果返回给用户



#### 明确 range 访问方法的范围区间

其实对于`B+`树索引来说，只要索引列和常数使用`=`、`<=>`、`IN`、`NOT IN`、`IS NULL`、`IS NOT NULL`、`>`、`<`、`>=`、`<=`、`BETWEEN`、`!=`（不等于也可以写成`<>`）或者`LIKE`操作符连接起来，就可以产生一个所谓的`区间`

而在日常使用时，`WHERE` 子句一般会有很多个搜索条件，通过 `AND` 或者 `OR` 来连接

- `cond1 AND cond2` ：只有当 `cond1` 和 `cond2` 都为 `TRUE` 时整个表达式才为 `TRUE`
- `cond1 OR cond2` ：只有当 `cond1` 或者 `cond2` 有一个为 `TRUE` 时整个表达式就为 `TRUE`



对于使用 `range` 方法方法时，我们可以明确 `范围区间 `，这时的操作技巧就是，将不能使用到目标索引的条件都用 `TRUE` 替换，因为不能使用索引的条件，会在索引结果回表取出后再进行筛选，并不影响索引扫描的范围区间。然后通过上面的两个 `AND` 及 `OR` 的组合进行集合运算，然后将会得到最终的 `范围区间 `

```sql
-- 第一种情况，最简单的情况，所有条件都使用了目标索引，直接运算
-- AND 做交集，范围区间是 key2 > 200
SELECT * FROM single_table WHERE key2 > 100 AND key2 > 200;
-- OR 做并集，范围区间是 key2 > 100
SELECT * FROM single_table WHERE key2 > 100 OR key2 > 200;

-- 第二种情况，部分条件无法使用索引
SELECT * FROM single_table WHERE key2 > 100 AND common_field = 'abc';
-- 2.1 此时可以将 common_field = 'abc' 这个条件替换为 TRUE，得到
SELECT * FROM single_table WHERE key2 > 100 AND TRUE;
-- 2.2 所以范围区间是 key2 > 100

-- 第三种跟第二种差不多，但是比较复杂
SELECT * FROM single_table WHERE 
        (key1 > 'xyz' AND key2 = 748 ) OR
        (key1 < 'abc' AND key1 > 'lmn') OR
        (key1 LIKE '%suf' AND key1 > 'zzz' AND (key2 < 8000 OR common_field = 'abc')) ;
-- 3.1 这个 SQL 可以使用 索引 idx_key1 也可以使用 idx_key2
-- 3.2 以使用 索引idx_key1 进行计算，将不相关的列都替换为 TRUE，得到
SELECT * FROM single_table WHERE 
        (key1 > 'xyz' AND TRUE ) OR
        (key1 < 'abc' AND key1 > 'lmn') OR
        (TRUE AND key1 > 'zzz' AND (TRUE OR TRUE)) ;
-- 3.3 化简得
SELECT * FROM single_table WHERE 
        key1 > 'xyz' OR
        (key1 < 'abc' AND key1 > 'lmn') OR
        (key1 > 'zzz') ;
-- 3.4 key1 < 'abc' AND key1 > 'lmn' 这个条件是不成立的，所以可以直接舍弃，得到
SELECT * FROM single_table WHERE key1 > 'xyz' OR key1 > 'zzz';
-- 3.5 OR 操作符取并集，所以最后范围区间是 key1 > 'xyz'

-- 3.6 以使用 索引idx_key2 进行计算，将不相关的列都替换为 TRUE，得到
SELECT * FROM single_table WHERE 
        (TRUE AND key2 = 748 ) OR
        (TRUE AND TRUE) OR
        (TRUE AND TRUE AND (key2 < 8000 OR TRUE)) ;
-- 3.7 化简得
SELECT * FROM single_table WHERE key2 = 748 OR TRUE OR TRUE;
-- 再化简得
SELECT * FROM single_table WHERE TRUE;
-- 这个时候范围区间就是全表扫描，两个索引方案对比，所以就会选择使用 索引idx_key1
```



#### 索引合并

通常情况下，一次查询只会使用一个索引，但是也有特殊情况，MySQL 会同时使用多个索引，称之为 `index merge`



##### Intersection 合并

```sql
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
```

触发 `Intersection合并` 的必要条件：

1. 二级索引是等值查询；如果是组合索引，组合索引的每一位都必须覆盖到，不能只是部分
2. InnoDB表上的主键范围查询条件

> 注意：
>
> 并不是说满足了必要条件后，就一定会选择使用 `Intersection合并` 的方式，最终还是由优化器根据实际数据情况进行判断



流程如下：

1. 在索引 `idx_key1` 中取出满足 `key1 = 'a'` 的所有记录
2. 在索引 `idx_key2` 中取出满足 `key1 = 'b'` 的所有记录
3. 前面两个取出的结果集，因为二级索引的特点，相同值记录是以主键进行排序的，所以需要通过主键对两个排序的结果列表取交集，这个合并过程的时间复杂度是 O(n)
4. 将合并的结果集回表查询完整的数据记录



`Intersection合并` 相比较通过单个索引查询后回表，有以下区别：

1. `Intersection合并` 需要访问两个索引树，而单个索引查询仅需要访问一个，但是由于基于索引树的等值匹配，数据的读取是 `顺序IO`，所以速度也不慢
2. `Intersection合并` 需要对两个结果取交集，因为结果都是针对主键排序的，所以合并两个有序列表的时间复杂度是 O(n)，效率比较高
3. `Intersection合并`  是在去交集完成之后再回表查询数据，而单个索引查询是完成单个条件的匹配后就会去回表查询，所以一般而言，`Intersection合并`  回表的数据会比单个索引查询要少很多，而回表操作属于 `随机IO` 效率较低，尤其是等值匹配的数据越多，交集越少，`Intersection合并` 的优势越大



> 注意，如果条件不是等值匹配是不能 `Intersection合并` 的，但是如果加入的是主键做范围匹配，则不受影响依然可以使用  `Intersection合并` ，因为主键的范围匹配也可以在查询二级索引数据时完成并且不影响结果以主键排序
>
> ```sql
> -- 不能执行 Intersection合并
> SELECT * FROM single_table WHERE key1 = 'a' AND key3 > 'b';
> 
> -- 可以执行 Intersection合并
> SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b' AND id > 100;
> ```



##### Union 合并

```sql
SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b'
```

触发 `Union` 索引合并 的必要条件：

1. 二级索引是等值查询；如果是组合索引，组合索引的每一位都必须覆盖到，不能只是部分
2. 主键列可以是范围匹配
3. 使用 `Intersection` 索引合并的搜索条件

> 注意，查询条件符合了这些情况也不一定就会采用 `Union` 索引合并，优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过 `Union` 索引合并后进行访问的代价比全表扫描更小时才会使用 `Union` 索引合并



以 `key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' OR (key1 = 'a' AND key3 = 'b');` 这个 SQL 为例， 流程如下：

1. 先按 `key1 = 'a' AND key3 = 'b'` 通过 `Intersection合并` 获取到一个主键集合
2. 按 `key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c'` 条件从索引 idx_key_part 中获取到另外一个主键集合
3. 采用  `Union合并`  方式将上述两个集合取并集，然后进行回表操作，并将结果返回到用户



##### Sort-Union 合并

```sql
SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z'
```



以上的 SQL 执行可能流程如下：

1. 在 索引 idx_key1 中查出符合条件 `key1 < 'a'` 的数据集合
2. 在 索引 idx_key3 中查出符合条件 `key3 > 'z'` 的数据集合
3. 将两个数据集合分别按主键值排序，再将两个集合合并到一起



参考上面的流程，因为是 range 取值，所以第一步查出来的结果并不是按主键值排序的，所以对比 `Union合并`  就多了一个分别为每个结果排序的过程。很显然这种方式主要适用于两个查询结果都不太大的情况，这样排序的代价才会比较小

而对于 `Intersection合并` 的情况，一般是用于将两个较大的集合合并为较小的集合的场景，以减少回表提高效率，所以没有 `Sort-Intersection合并` ，因为在这种情况下，明显排序的效率会比较低



## 多表访问方法

### 连接

`join` (连接) 就是将多个表的数据，按指定的条件组合到一起，连接分为内连接，左连接及右连接

左连接和右连接都是外连接，外连接跟内连接的区别在于，被驱动表的数据匹配不到时，外连接会将这条记录依然加入结果，而内连接不会。左连接和右连接的区别在于，左连接驱动表在左被驱动表在右，而右连接驱动表在右被驱动表在左

```sql
-- 内连接
SELECT * FROM t1, t2 WHERE 连接条件 [AND 普通过滤条件];
SELECT * FROM t1 [INNER | CROSS] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];

-- 左连接
SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];

-- 右连接
SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
```



#### 连接的原理



##### 嵌套循环连接（Nested-Loop Join）

对于两个表连接查询而言，驱动表的数据只需要读取一次，而被驱动表的数据需要读取很多次，因为需要在被驱动表不断找出满足连接条件的记录，所以最简单粗暴的流程就是：

1. 选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询
2. 对第一步查询的结果进行遍历，在被驱动表中足连接条件的记录进行连接



这整个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为`嵌套循环连接`（`Nested-Loop Join`）



##### 使用索引加快连接速度

在上面的查询中，主要的时间瓶颈在于，需要不断的查询被驱动表，所以连接条件满足索引搜索的条件时，就能有效的降低查询被驱动表的时间开销

例如下面的 SQL：

```sql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

连接条件是 `t1.m1 = t2.m2` 和 ` t2.n2 < 'd'`，假设两个字段都有索引，那么就跟单表查询一样，优化器会选择一个效率比较高的方式进行搜索，`t1.m1 = t2.m2`  是用等值匹配进行查询，可能是以`ref` 的方式进行查询，（假如 `m2` 字段是主键或者唯一索引，那查询代价将是常数级别，这种查询方式被称为 `eq_ref`），` t2.n2 < 'd'` 这个条件可能是使用 `range` 的方式进行查询

两个比较就比较有可能会选择前面的索引，但是两个都有索引也不一定就会使用索引，优化器会判断使用所以后回表代价比较小的时候，才会去使用索引

> 注意：
>
> 跟单表查询类似的，如果依赖索引查询被驱动表时，不需要查询索引以外的信息(覆盖索引)，那么将不需要回表，这将大大提高查询效率，所以实际业务中最好按需查询而不是全都使用 * 作为查询列表



##### 基于块的嵌套循环连接（Block Nested-Loop Join）

考虑几种情况：

1. 当驱动表查询的数据非常多时，不能一次性全部加载进内存，所以需要分批加载
2. 当不能使用索引加速时，每次驱动表的数据都需要引起一次被驱动表的查询，效率比较低



所以 MySQL 引入一个 `join buffer` 的概念，会将驱动表的数据都读取到这个大小固定的缓存中，加入需要对被驱动表进行遍历时，就会将数据取出，在缓存中与所有缓存数据都进行比较，假如驱动表查询结果数量为n，就会把原来 n 次的被驱动表查询降低为 n * 记录大小 / 缓存大小 次，显著降低 I/O 提高效率，这种方式就称之为 `基于块的嵌套循环连接（Block Nested-Loop Join)` 算法

> 注意：
>
> 查询时只会将需要查询的列和过滤条件中的列加载进缓存，所以按需查询而不是全都使用 * 作为查询列表可以使 `join buffer`  加载更多的数据以提高效率
>
> `join buffer`  的大小是通过 `join_buffer_size` 这个变量来控制的，默认大小是 256KB



